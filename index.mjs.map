{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-invalid-this, no-restricted-syntax */\n\n'use strict';\n\n// MODULES //\n\nimport isArrayBuffer from '@stdlib/assert-is-arraybuffer';\nimport isObject from '@stdlib/assert-is-object';\nimport hasProp from '@stdlib/assert-has-property';\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport setReadWriteAccessor from '@stdlib/utils-define-nonenumerable-read-write-accessor';\nimport setReadOnlyAccessor from '@stdlib/utils-define-nonenumerable-read-only-accessor';\nimport propertyDescriptor from '@stdlib/utils-property-descriptor';\nimport { factory as contains } from '@stdlib/array-base-assert-contains';\nimport join from '@stdlib/array-base-join';\nimport objectAssign from '@stdlib/object-assign';\nimport inherit from '@stdlib/utils-inherit';\nimport resolveStr from '@stdlib/stats-base-ztest-alternative-resolve-str';\nimport resolveEnum from '@stdlib/stats-base-ztest-alternative-resolve-enum';\nimport structFactory from '@stdlib/stats-base-ztest-two-sample-results-struct-factory';\nimport res2json from '@stdlib/stats-base-ztest-two-sample-results-to-json';\nimport res2str from '@stdlib/stats-base-ztest-two-sample-results-to-string';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// VARIABLES //\n\nvar DTYPES = [\n\t'float64',\n\t'float32'\n];\n\nvar isDataType = contains( DTYPES );\n\n\n// MAIN //\n\n/**\n* Returns a constructor for creating a two-sample Z-test results object.\n*\n* @param {string} dtype - storage data type for floating-point values\n* @throws {TypeError} first argument must be a supported data type\n* @returns {Function} constructor\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var Results = factory( 'float64' );\n*\n* var results = new Results();\n* // returns <Results>\n*\n* results.alternative = 'two-sided';\n* results.alpha = 0.05;\n* results.nullValue = 0.0;\n* results.pValue = 0.0132;\n* results.statistic = 2.4773;\n* results.xmean = 3.7561;\n* results.ymean = 3.0129;\n* results.ci = new Float64Array( [ 0.1552, 1.3311 ] );\n* results.rejected = true;\n*\n* var str = results.toString();\n* // returns <string>\n*/\nfunction factory( dtype ) {\n\tvar alternativeDescriptor;\n\tvar Struct;\n\n\tif ( !isDataType( dtype ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be one of the following: \"%s\". Value: `%s`.', join( DTYPES, ', ' ), dtype ) );\n\t}\n\n\t// Create a struct constructor:\n\tStruct = structFactory( dtype );\n\n\t// Cache a reference to a property descriptor on the parent prototype so that we can intercept the return value:\n\talternativeDescriptor = propertyDescriptor( Struct.prototype, 'alternative' );\n\n\t/**\n\t* Returns a two-sample Z-test results object.\n\t*\n\t* @private\n\t* @constructor\n\t* @param {(ArrayBuffer|Object)} [arg] - underlying byte buffer or a data object\n\t* @param {NonNegativeInteger} [byteOffset] - byte offset\n\t* @param {NonNegativeInteger} [byteLength] - maximum byte length\n\t* @throws {TypeError} first argument must be an ArrayBuffer or a data object\n\t* @returns {Results} results object\n\t*/\n\tfunction Results( arg, byteOffset, byteLength ) {\n\t\tvar nargs;\n\t\tvar args;\n\t\tvar v;\n\t\tvar i;\n\n\t\tnargs = arguments.length;\n\t\tif ( !( this instanceof Results ) ) {\n\t\t\tif ( nargs === 0 ) {\n\t\t\t\treturn new Results();\n\t\t\t}\n\t\t\tif ( nargs === 1 ) {\n\t\t\t\treturn new Results( arg );\n\t\t\t}\n\t\t\tif ( nargs === 2 ) {\n\t\t\t\treturn new Results( arg, byteOffset );\n\t\t\t}\n\t\t\treturn new Results( arg, byteOffset, byteLength );\n\t\t}\n\t\targs = [];\n\t\tif ( nargs > 0 ) {\n\t\t\tif ( isArrayBuffer( arg ) ) {\n\t\t\t\tfor ( i = 0; i < nargs; i++ ) {\n\t\t\t\t\targs.push( arguments[ i ] );\n\t\t\t\t}\n\t\t\t} else if ( isObject( arg ) ) {\n\t\t\t\tif ( hasProp( arg, 'alternative' ) ) {\n\t\t\t\t\targs.push( objectAssign( {}, arg ) );\n\t\t\t\t\tv = resolveEnum( args[ 0 ].alternative );\n\t\t\t\t\targs[ 0 ].alternative = ( v === null ) ? NaN : v;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new TypeError( format( 'invalid argument. First argument must be an ArrayBuffer or a data object. Value: `%s`.', arg ) );\n\t\t\t}\n\t\t}\n\t\t// Call the parent constructor...\n\t\tStruct.apply( this, args );\n\t\treturn this;\n\t}\n\n\t/*\n\t* Inherit from the parent constructor.\n\t*/\n\tinherit( Results, Struct );\n\n\t/**\n\t* Constructor name.\n\t*\n\t* @private\n\t* @name name\n\t* @memberof Results\n\t* @readonly\n\t* @type {string}\n\t*/\n\tsetReadOnly( Results, 'name', Struct.name );\n\n\t/**\n\t* Alignment.\n\t*\n\t* @private\n\t* @name alignment\n\t* @memberof Results\n\t* @readonly\n\t* @type {PositiveInteger}\n\t*/\n\tsetReadOnly( Results, 'alignment', Struct.alignment );\n\n\t/**\n\t* Size (in bytes) of the `struct`.\n\t*\n\t* @private\n\t* @name byteLength\n\t* @memberof Results\n\t* @readonly\n\t* @type {PositiveInteger}\n\t*/\n\tsetReadOnly( Results, 'byteLength', Struct.byteLength );\n\n\t/**\n\t* Returns a list of `struct` fields.\n\t*\n\t* @private\n\t* @name fields\n\t* @memberof Results\n\t* @readonly\n\t* @type {Array<string>}\n\t*/\n\tsetReadOnlyAccessor( Results, 'fields', function get() {\n\t\treturn Struct.fields;\n\t});\n\n\t/**\n\t* Returns a string corresponding to the `struct` layout.\n\t*\n\t* @private\n\t* @name layout\n\t* @memberof Results\n\t* @readonly\n\t* @type {string}\n\t*/\n\tsetReadOnlyAccessor( Results, 'layout', function get() {\n\t\treturn Struct.layout;\n\t});\n\n\t/**\n\t* Returns the underlying byte buffer of a `struct`.\n\t*\n\t* @private\n\t* @name bufferOf\n\t* @memberof Results\n\t* @readonly\n\t* @type {Function}\n\t* @param {Object} obj - struct instance\n\t* @throws {TypeError} must provide a `struct` instance\n\t* @returns {ArrayBuffer} underlying byte buffer\n\t*/\n\tsetReadOnly( Results, 'bufferOf', Struct.bufferOf );\n\n\t/**\n\t* Returns the length, in bytes, of the value specified by the provided field name.\n\t*\n\t* @private\n\t* @name byteLengthOf\n\t* @memberof Results\n\t* @readonly\n\t* @type {Function}\n\t* @param {string} name - field name\n\t* @throws {Error} struct must have at least one field\n\t* @throws {TypeError} must provide a recognized field name\n\t* @returns {NonNegativeInteger} byte length\n\t*/\n\tsetReadOnly( Results, 'byteLengthOf', Struct.byteLengthOf );\n\n\t/**\n\t* Returns the offset, in bytes, from the beginning of a `struct` to the value specified by the provided field name.\n\t*\n\t* @private\n\t* @name byteOffsetOf\n\t* @memberof Results\n\t* @readonly\n\t* @type {Function}\n\t* @param {string} name - field name\n\t* @throws {Error} struct must have at least one field\n\t* @throws {TypeError} must provide a recognized field name\n\t* @returns {NonNegativeInteger} byte offset\n\t*/\n\tsetReadOnly( Results, 'byteOffsetOf', Struct.byteOffsetOf );\n\n\t/**\n\t* Returns the description associated with a provided field name.\n\t*\n\t* @private\n\t* @name descriptionOf\n\t* @memberof Results\n\t* @readonly\n\t* @type {Function}\n\t* @param {string} name - field name\n\t* @throws {Error} struct must have at least one field\n\t* @throws {TypeError} must provide a recognized field name\n\t* @returns {string} description\n\t*/\n\tsetReadOnly( Results, 'descriptionOf', Struct.descriptionOf );\n\n\t/**\n\t* Returns a boolean indicating whether a provided value is a `struct` instance.\n\t*\n\t* @private\n\t* @name isStruct\n\t* @memberof Results\n\t* @readonly\n\t* @type {Function}\n\t* @param {*} value - input valueAdd commentMore actions\n\t* @returns {boolean} boolean indicating whether a value is a `struct` instance\n\t*/\n\tsetReadOnly( Results, 'isStruct', Struct.isStruct );\n\n\t/**\n\t* Returns the type associated with a provided field name.\n\t*\n\t* @private\n\t* @name typeOf\n\t* @memberof Results\n\t* @readonly\n\t* @type {Function}\n\t* @param {string} name - field nameAdd commentMore actions\n\t* @throws {Error} struct must have at least one field\n\t* @throws {TypeError} must provide a recognized field name\n\t* @returns {(string|Object)} type\n\t*/\n\tsetReadOnly( Results, 'typeOf', Struct.typeOf );\n\n\t/**\n\t* Returns the underlying byte buffer of a `struct` as a `DataView`.\n\t*\n\t* @private\n\t* @name viewOf\n\t* @memberof Results\n\t* @readonly\n\t* @type {Function}\n\t* @param {Object} obj - struct instance\n\t* @throws {TypeError} must provide a `struct` instance\n\t* @returns {DataView} view of underlying byte buffer\n\t*/\n\tsetReadOnly( Results, 'viewOf', Struct.viewOf );\n\n\t/**\n\t* Test name.\n\t*\n\t* @private\n\t* @name method\n\t* @memberof Results.prototype\n\t* @type {string}\n\t* @default 'Two-sample Z-test'\n\t*/\n\tsetReadOnly( Results.prototype, 'method', 'Two-sample Z-test' );\n\n\t/**\n\t* Alternative hypothesis.\n\t*\n\t* @private\n\t* @name alternative\n\t* @memberof Results.prototype\n\t* @type {string}\n\t*/\n\tsetReadWriteAccessor( Results.prototype, 'alternative', getAlternative, setAlternative );\n\n\t/**\n\t* Serializes a results object as a string.\n\t*\n\t* ## Notes\n\t*\n\t* -   Example output:\n\t*\n\t*     ```text\n\t*\n\t*     Two-sample Z-test\n\t*\n\t*     Alternative hypothesis: True difference in means is less than 1.0\n\t*\n\t*        pValue: 0.0406\n\t*        statistic: 9.9901\n\t*        95% confidence interval: [9.7821, 10.4451]\n\t*\n\t*     Test Decision: Reject null in favor of alternative at 5% significance level\n\t*\n\t*     ```\n\t*\n\t* @private\n\t* @name toString\n\t* @memberof Results.prototype\n\t* @type {Function}\n\t* @param {Options} [opts] - options object\n\t* @param {PositiveInteger} [opts.digits=4] - number of digits after the decimal point\n\t* @param {boolean} [opts.decision=true] - boolean indicating whether to show the test decision\n\t* @throws {TypeError} options argument must be an object\n\t* @throws {TypeError} must provide valid options\n\t* @returns {string} serialized results\n\t*/\n\tsetReadOnly( Results.prototype, 'toString', function toString( opts ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn res2str( this, opts );\n\t\t}\n\t\treturn res2str( this );\n\t});\n\n\t/**\n\t* Serializes a results object as a JSON object.\n\t*\n\t* ## Notes\n\t*\n\t* -   `JSON.stringify()` implicitly calls this method when stringifying a `Results` instance.\n\t*\n\t* @private\n\t* @name toJSON\n\t* @memberof Results.prototype\n\t* @type {Function}\n\t* @returns {Object} serialized object\n\t*/\n\tsetReadOnly( Results.prototype, 'toJSON', function toJSON() {\n\t\treturn res2json( this );\n\t});\n\n\t/**\n\t* Returns a DataView of a results object.\n\t*\n\t* @private\n\t* @name toDataView\n\t* @memberof Results.prototype\n\t* @type {Function}\n\t* @returns {DataView} DataView\n\t*/\n\tsetReadOnly( Results.prototype, 'toDataView', function toDataView() {\n\t\treturn Struct.viewOf( this );\n\t});\n\n\treturn Results;\n\n\t/**\n\t* Returns the alternative hypothesis.\n\t*\n\t* @private\n\t* @returns {string} alternative hypothesis\n\t*/\n\tfunction getAlternative() {\n\t\treturn resolveStr( alternativeDescriptor.get.call( this ) );\n\t}\n\n\t/**\n\t* Sets the alternative hypothesis.\n\t*\n\t* @private\n\t* @param {string} value - alternative hypothesis\n\t*/\n\tfunction setAlternative( value ) {\n\t\talternativeDescriptor.set.call( this, resolveEnum( value ) );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default factory;\n"],"names":["DTYPES","isDataType","contains","factory","dtype","alternativeDescriptor","Struct","TypeError","format","join","Results","arg","byteOffset","byteLength","nargs","args","v","i","arguments","length","this","isArrayBuffer","push","isObject","hasProp","objectAssign","resolveEnum","alternative","NaN","apply","structFactory","propertyDescriptor","prototype","inherit","setReadOnly","name","alignment","setReadOnlyAccessor","fields","layout","bufferOf","byteLengthOf","byteOffsetOf","descriptionOf","isStruct","typeOf","viewOf","setReadWriteAccessor","resolveStr","get","call","value","set","opts","res2str","res2json"],"mappings":";;gvDA6CA,IAAIA,EAAS,CACZ,UACA,WAGGC,EAAaC,EAAUF,GAiC3B,SAASG,EAASC,GACjB,IAAIC,EACAC,EAEJ,IAAML,EAAYG,GACjB,MAAM,IAAIG,UAAWC,EAAQ,oFAAqFC,EAAMT,EAAQ,MAAQI,IAoBzI,SAASM,EAASC,EAAKC,EAAYC,GAClC,IAAIC,EACAC,EACAC,EACAC,EAGJ,GADAH,EAAQI,UAAUC,SACVC,gBAAgBV,GACvB,OAAe,IAAVI,EACG,IAAIJ,EAEG,IAAVI,EACG,IAAIJ,EAASC,GAEN,IAAVG,EACG,IAAIJ,EAASC,EAAKC,GAEnB,IAAIF,EAASC,EAAKC,EAAYC,GAGtC,GADAE,EAAO,GACFD,EAAQ,EACZ,GAAKO,EAAeV,GACnB,IAAMM,EAAI,EAAGA,EAAIH,EAAOG,IACvBF,EAAKO,KAAMJ,UAAWD,QAEjB,KAAKM,EAAUZ,GAOrB,MAAM,IAAIJ,UAAWC,EAAQ,yFAA0FG,IANlHa,EAASb,EAAK,iBAClBI,EAAKO,KAAMG,EAAc,CAAA,EAAId,IAC7BK,EAAIU,EAAaX,EAAM,GAAIY,aAC3BZ,EAAM,GAAIY,YAAsB,OAANX,EAAeY,IAAMZ,EAIhD,CAIF,OADAV,EAAOuB,MAAOT,KAAML,GACbK,IACP,CAiQD,OAvTAd,EAASwB,EAAe1B,GAGxBC,EAAwB0B,EAAoBzB,EAAO0B,UAAW,eAwD9DC,EAASvB,EAASJ,GAWlB4B,EAAaxB,EAAS,OAAQJ,EAAO6B,MAWrCD,EAAaxB,EAAS,YAAaJ,EAAO8B,WAW1CF,EAAaxB,EAAS,aAAcJ,EAAOO,YAW3CwB,EAAqB3B,EAAS,UAAU,WACvC,OAAOJ,EAAOgC,MAChB,IAWCD,EAAqB3B,EAAS,UAAU,WACvC,OAAOJ,EAAOiC,MAChB,IAcCL,EAAaxB,EAAS,WAAYJ,EAAOkC,UAezCN,EAAaxB,EAAS,eAAgBJ,EAAOmC,cAe7CP,EAAaxB,EAAS,eAAgBJ,EAAOoC,cAe7CR,EAAaxB,EAAS,gBAAiBJ,EAAOqC,eAa9CT,EAAaxB,EAAS,WAAYJ,EAAOsC,UAezCV,EAAaxB,EAAS,SAAUJ,EAAOuC,QAcvCX,EAAaxB,EAAS,SAAUJ,EAAOwC,QAWvCZ,EAAaxB,EAAQsB,UAAW,SAAU,qBAU1Ce,EAAsBrC,EAAQsB,UAAW,eA+EzC,WACC,OAAOgB,EAAY3C,EAAsB4C,IAAIC,KAAM9B,MACnD,IAQD,SAAyB+B,GACxB9C,EAAsB+C,IAAIF,KAAM9B,KAAMM,EAAayB,GACnD,IAzDDjB,EAAaxB,EAAQsB,UAAW,YAAY,SAAmBqB,GAC9D,OAAKnC,UAAUC,OACPmC,EAASlC,KAAMiC,GAEhBC,EAASlC,KAClB,IAeCc,EAAaxB,EAAQsB,UAAW,UAAU,WACzC,OAAOuB,EAAUnC,KACnB,IAWCc,EAAaxB,EAAQsB,UAAW,cAAc,WAC7C,OAAO1B,EAAOwC,OAAQ1B,KACxB,IAEQV,CAqBR"}